package main

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"image"
	"image/color"
	"image/draw"
	"image/png"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
	"strconv"
	"zetamachine/pkg/lambda"
	"zetamachine/pkg/zeta"
)

func backgroundTile(zoom, x, y int) bool {
	// tile := zeta.Tile{
	// 	Size:       size,
	// 	Zoom:       zoom,
	// 	X:          x,
	// 	Y:          y,
	// 	TotalUnits: totalUnits,
	// 	GlobalMin:  globalMin,
	// }

	// max := tile.Max()
	// min := tile.Min()
	// if zoom > 3 && (real(min) >= 20) {
	// 	fmt.Println("tile:", x, y, "min:", min)
	// 	return true
	// }

	// fmt.Println("zoom:", zoom, "tile:", x, y, "extents:", min, max)
	return false
}

func handleGenerate(luts []*zeta.LUT) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		args, err := zeta.ParseTileArgs(r)
		if err != nil {
			http.Error(w, "Error generating tile: "+err.Error(), 500)
			return
		}

		png, err := zeta.NewTile(args.Zoom, args.X, args.Y)
		writeImage(w, png)
	})
}

// request the tile to be generated by the render farm
func requestTile(tile *zeta.Tile) (*bytes.Reader, error) {
	url := os.Getenv("ZETA_TILE_GENERATOR_URL")

	buf, err := json.Marshal(tile)
	if err != nil {
		return nil, err
	}

	r := bytes.NewReader(buf)
	log.Println("Posting request for tile:", tile)
	log.Println(url)

	resp, err := http.Post(url, "application/json", r)
	if err != nil {
		log.Println("Request for tile generation failed: ", err)
		return nil, err
	}

	if resp.StatusCode != 200 {
		log.Println("Failed request for tile generation: ", resp.StatusCode, resp.Status)
		return nil, errors.New(fmt.Sprint("Failed request for tile generation: ", tile, resp.StatusCode, resp.Status))
	}

	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Println("Failed to read all bytes from response: ", err)
		return nil, err
	}

	result := &lambda.RenderTileResponse{}
	if err := json.Unmarshal(b, result); err != nil {
		log.Println("Failed to unmarshal tile: ", err)
		return nil, err
	}

	png, err := base64.StdEncoding.DecodeString(result.Image)
	if err != nil {
		log.Println("Failed to decode base64 image: ", err)
		return nil, err
	}

	return bytes.NewReader(png), nil
}

// writeImage encodes an image 'img' in jpeg format and writes it into ResponseWriter.
func writeImage(w http.ResponseWriter, img *image.Image) {
	buffer := new(bytes.Buffer)
	if err := png.Encode(buffer, *img); err != nil {
		log.Println("unable to encode image.")
	}

	w.Header().Set("Content-Type", "image/png")
	w.Header().Set("Content-Length", strconv.Itoa(len(buffer.Bytes())))
	if _, err := w.Write(buffer.Bytes()); err != nil {
		log.Println("unable to write image.")
	}
}

func handleTileReq(s *server) http.HandlerFunc {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		cwd, _ := os.Getwd()

		tile, err := zeta.ParseTileArgs(r)
		if err != nil {
			http.Error(w, err.Error(), 500)
			return
		}

		// don't save tiles that don't contain anything
		if backgroundTile(tile.Zoom, tile.X, tile.Y) {
			bkg := color.RGBA{255, 0, 0, 255} // background color of website
			img := image.NewRGBA(image.Rect(0, 0, 256, 256))
			draw.Draw(img, img.Bounds(), &image.Uniform{bkg}, image.ZP, draw.Src)
			var i image.Image = img
			writeImage(w, &i)
			return
		}

		fpath := path.Join(cwd, tile.Path())
		fname := path.Join(fpath, tile.Filename())
		if _, err := os.Stat(fname); err == nil {
			http.ServeFile(w, r, fname)
		} else {

			// png, err := internalLambdaTile(tile)
			png, err := requestTile(tile)
			if err != nil {
				http.Error(w, err.Error(), 500)
				return
			}

			// does not return an error if the path exists.
			// creates the path recusively
			if err := createFolder(fpath); err != nil {
				http.Error(w, err.Error(), 500)
				return
			}

			f, err := os.Create(fname)
			if err != nil {
				http.Error(w, err.Error(), 500)
				return
			}
			defer f.Close()

			_, err = io.Copy(f, png)
			if err != nil {
				http.Error(w, err.Error(), 500)
				return
			}
			f.Close()

			http.ServeFile(w, r, fname)
		}
	})
}

func getTileBytes(url string) (*bytes.Buffer, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var buf bytes.Buffer
	if err := resp.Write(&buf); err != nil {
		return nil, err
	}

	return &buf, nil
}
